package main

import (
	"context"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"syscall"
	"time"

	"github.com/google/uuid"
	"github.com/xigxog/kubefox/libs/core/grpc"
	"github.com/xigxog/kubefox/libs/core/model"
	gogrpc "google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type tokenProvider struct {
	id     string
	name   string
	commit string
}

func (p *tokenProvider) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	return map[string]string{
		"componentId":     p.id,
		"componentName":   p.name,
		"componentCommit": p.commit,
		"accountId":       "392db620-1828-423f-a457-4c5680fb7787",
		"authToken":       "eyJhbGciOiJSUzI1NiIsImtpZCI6IlFZNDJITzZZcGl0c3kzTjQ0Wl9DWkxfR3R0TmJRMkE2SkhZeW9wU3NQcWcifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjkzMzI2MDI4LCJpYXQiOjE2OTMzMjI0MjgsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlZm94LXN5c3RlbSIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJtYWluLXZhdWx0IiwidWlkIjoiMzkyZGI2MjAtMTgyOC00MjNmLWE0NTctNGM1NjgwZmI3Nzg3In19LCJuYmYiOjE2OTMzMjI0MjgsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlZm94LXN5c3RlbTptYWluLXZhdWx0In0.ufIurFiQPplxMrprERvU4QMNj7C7tmwZa52JDWCzV4Fz48C3VIV2NwIgs1ygmp_MSthWVOA53CCTEjaZB3VSDKd8yWZJXs-lx1-szuQoAS5y9BMPSA6vHxJBXaVLqw0dlwazJDDq-OvDxKjfIwiBiSq-3DvjZtMTDnvni4SC8ttWbXcDRRSrrOX9XdnzOEffmYnPQxkC8G9WEiPCa4BflKRB1ZvIX04ixzPou09U5qMwcBGvTX3kh4thkm3BVo6nsyLYeRM4HyjsjVKuEcYrzZcKh6jwSMviHkX7sO9Vill3TKxvx5HPvkgNjjctfk1N6eAwvTfn5wVZZegYcxhWFQ",
	}, nil
}

func (p *tokenProvider) RequireTransportSecurity() bool {
	return false
}

func test(name string, workerId int, conn *gogrpc.ClientConn) {
	client := grpc.NewBrokerClient(conn)

	stream, err := client.Subscribe(context.Background())
	if err != nil {
		log.Printf("subscribe failed: %v\n", err)
		return
	}

	defer func() {
		if err := conn.Close(); err != nil {
			log.Printf("conn close err: %v", err)
		}

		log.Printf("worker %d done\n", workerId)
		wg.Done()
	}()

	latch := make(chan struct{})

	src := &model.Component{
		Id:     name + "-" + strconv.Itoa(workerId),
		Name:   name,
		Commit: "aaaaaaa",
	}
	tgt := &model.Component{
		Name:   target,
		Commit: "aaaaaaa",
	}

	var mutex sync.RWMutex
	reqMap := make(map[string]chan *model.Event)
	var closed atomic.Bool

	go func() {
		defer func() {
			closed.Store(true)
			latch <- struct{}{}
		}()

		for {
			evt, err := stream.Recv()
			if err == io.EOF || evt == nil {
				// read done.
				log.Printf("worker %d recv got EOF\n", workerId)
				return
			}
			if err != nil {
				log.Printf("worker %d recv failed: %v\n", workerId, err)
				return
				// if e, ok := status.FromError(err); ok && e.Code() != codes.Canceled {
				// 	log.Printf("recv failed: %v\n", err)
				// }
			}

			bumpRecvd()

			if count <= 5 {
				log.Printf("worker %d recvd msg; id=%s, src=%v\n", workerId, evt.Id, evt.Source)
			}

			if evt.Category == model.Category_CATEGORY_REQUEST {
				resp := model.NewEvent()
				resp.Id = evt.Id + "-resp"
				resp.ParentId = evt.Id
				resp.Category = model.Category_CATEGORY_RESPONSE
				resp.Type = "test-resp"
				resp.Source = src
				resp.Target = evt.Source

				if count <= 5 {
					log.Printf("worker %d sending resp %s\n", workerId, resp.Id)
				}

				if err := stream.Send(resp); err != nil {
					log.Printf("worker %d send failed for resp %s: %v\n", workerId, resp.Id, err)
					return
				}

			} else {
				mutex.Lock()
				if ch, found := reqMap[evt.ParentId]; found {
					delete(reqMap, evt.ParentId)
					mutex.Unlock()
					ch <- evt

				} else {
					mutex.Unlock()
					log.Printf("worker %d no resp ch, ignoring id=%s\n", workerId, evt.Id)
				}
			}

		}
	}()

	if sender {
		sndStart := time.Now()
		for i := 0; i < count; i++ {
			evt := model.NewEvent()
			evt.Id = fmt.Sprintf("%d-%d-%s", workerId, i, uuid.New().String())
			evt.Type = "test-req"
			evt.Category = model.Category_CATEGORY_REQUEST
			evt.Source = src
			evt.Target = tgt

			if count <= 5 {
				log.Printf("worker %d sending msg %s\n", workerId, evt.Id)
			}

			if closed.Load() {
				log.Printf("worker %d stream closed before sending msg %d\n", workerId, i)
			}

			respCh := make(chan *model.Event)
			mutex.Lock()
			reqMap[evt.Id] = respCh
			mutex.Unlock()
			go func() {
				resp := <-respCh
				if count <= 5 {
					log.Printf("worker %d got resp; id=%s\n", workerId, resp.Id)
				}
			}()

			if err := stream.Send(evt); err != nil {
				log.Printf("worker %d send failed for msg %d: %v\n", workerId, i, err)
				return
			}
		}
		if count > 0 {
			log.Printf("worker %d sent %d msgs in %s\n", workerId, count, time.Since(sndStart))
		}
	}

	//block
	log.Println("blocking on latch")
	<-latch

	// if err := stream.CloseSend(); err != nil {
	// 	log.Printf("close send err: %v", err)
	// }

}

var (
	workers int
	count   int
	name    string
	target  string
	addr    string
	sender  bool

	totalRecvCount atomic.Int64
	totalRecvStart time.Time

	wg sync.WaitGroup
)

func main() {
	flag.IntVar(&workers, "workers", 1, "num of workers")
	flag.IntVar(&count, "count", 5, "num of messages to send per worker")
	flag.StringVar(&name, "name", "comp", "name of component")
	flag.StringVar(&target, "target", "comp", "name of target component")
	flag.StringVar(&addr, "addr", "127.0.0.1:6060", "addr of broker")
	flag.BoolVar(&sender, "sender", false, "if true test-client acts as sender")
	flag.Parse()

	addrs := strings.Split(addr, ",")

	wg.Add(workers)
	for i := 0; i < workers; i++ {
		log.Printf("worker %d starting\n", i)

		conn, err := gogrpc.Dial(addrs[i%len(addrs)],
			gogrpc.WithPerRPCCredentials(&tokenProvider{
				id:     name + "-" + strconv.Itoa(i),
				name:   name,
				commit: "aaaaaaa",
			}),
			gogrpc.WithTransportCredentials(insecure.NewCredentials()),
			// grpc.WithContextDialer(dialer),
		)
		if err != nil {
			log.Printf("fail to dial: %v\n", err)
			return
		}

		go test(name, i, conn)
	}

	ch := make(chan os.Signal, 1)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
	<-ch

	// wg.Wait()

	log.Printf("\n\ntotal recvd %d \n", totalRecvCount.Load())
}

func bumpRecvd() {
	if totalRecvCount.Add(1) == 1 {
		totalRecvStart = time.Now()
	}
	if totalRecvCount.Load() == int64(count*workers) {
		log.Printf("recv'd expected num of events in %s\n", time.Since(totalRecvStart))
	}
}
