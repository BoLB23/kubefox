# Concepts

Weâ€™ll start with brief descriptions of KubeFox constituents and gradually drop
deeper into detail.

## Event

: KubeFox operates on an event-driven architecture, where all requests and
responses, including synchronous calls, are conceptualized as Events and
communicated as messages among Components via brokers. The KubeFox Event model
offers a straightforward and versatile interface to encapsulate distinct, and
optionally typed, state changes.

: To illustrate, an HTTP request undergoes conversion by the HTTP Adapter into a
KubeFox Event, which is subsequently transmitted to a broker for routing to a
specific Component. The Component can then utilize the Event in a generic manner
or, alternatively, inspect its type and access type-specific attributes as
needed.

## Genesis Event

: A Genesis Event is an originating Event for a request. It is often generated
in response to an external request, such as an HTTP request. However, an
internal process, like a CRON trigger, could also give rise to a Genesis Event.
KubeFox dynamically determines the routing of a Genesis Event by matching it to
a registered Component Route associated with a Release. Conversely, the App
Deployment and Virtual Environment can be explicitly specified within the
Genesis Event, allowing for testing of App Deployments before an official
Release is created. Once a match is established, the request context, including
the App Deployment and Virtual Environment, is attached to to the Genesis Event
all subsequent child Events generated by the Components processing the request.

## Component

: A Component is a user-written microservice or function that leverages the
KubeFox Kit SDK. These Components offer capabilities to meet the requirements of
an App. Component source code is stored in a Git Repository that follows KubeFox
conventions. KubeFox handles building, packaging, testing, and deployment of
Components.

## App

: An App is a collections of Components which together provide useful
capabilities to end users of the software. Apps serve as the deployable unit in
the context of KubeFox. That means all Components of an App are deployed, and
optionally versioned, together.

## Repository

: A Repository is a Git repository housing one or more Apps. Components are
versioned through commits made to Git, enabling KubeFox to track modifications
to Components between App Deployments.

## Route

: A Route matches Events to a handler implemented by a Component. They are
written in a straightforward predicate-based language that supports boolean
logic. Optionally, a Route can contain logic to extract Event attributes into
named parameters, which are then passed to the handler.

## Broker

: A Broker serves as an Event router, responsible for matching and transporting
events between components. It determines the context of an Event and scrutinizes
the corresponding App Deployment to ensure that the event is authorized to be
passed to the matching Component. The Broker also injects Virtual Environment
variables and Adapter configurations into events as necessary.

## External Component

: An External Component refers to a third-party service that is not inherent to
KubeFox. Examples of External Components include PostgreSQL, Amazon S3, and
Kafka. Adapters provide connectivity with these Components by facilitating the
translation between the External Component's API and KubeFox Events.

## Adapter

: An adapter is a service which bidirectionally converts KubeFox Events to an
External Component's API. Adapters facilitate the interaction of Components with
services that are not native to KubeFox. For instance, the HTTP Adapter
translates both incoming HTTP requests and outgoing HTTP calls to and from
KubeFox Events.

## App Deployment

: An App Deployment comprises the definitions of both the App and its
Components. This encompasses the Component's Routes, OCI image name, and any
associated Virtual Environment variables or Adapters it depends on. Initiating
the creation of an App Deployment prompts the KubeFox operator to verify a
Kubernetes Pod exists for each specified Component.

: Optionally, an App Deployment can be assigned a version with semantic
significance. Once versioned, an App Deployment becomes immutable, guaranteeing
a static App definition. This facilitates releasing the App Deployment while
preserving a consistent and unchanging configuration for the specified version
of the App.

## Virtual Environment

: A Virtual Environment is an object encompassing a collection of variables and
Adapter configurations. A Component can specify dependencies on both Virtual
Environment variables and Adapters. During runtime, the broker extracts the
necessary variables from the Virtual Environment and attaches them to any Event
routed to the Component. Simultaneously, the broker attaches the requisite
configuration to Events directed to an Adapter.

: As Components explicitly define their dependencies, a Virtual Environment can
undergo validation at Release creation time. This ensures that the necessary
elements are in place for the proper functioning of Components within the
Virtual Environment.

## Release

: A Release binds an App Deployment and Virtual Environment together and
indicates to the Broker that Events matching the Component Routes of App
Deployment should be automatically routed to the matching Component. Once a
match is established, the request context, including the App Deployment and
Virtual Environment, is attached to all subsequent child Events generated by the
Components processing the request.
